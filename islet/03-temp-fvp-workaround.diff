
project frameworks/base/
diff --git a/packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java b/packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java
index 13690f30ab3b..b202fb39c0a3 100644
--- a/packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java
+++ b/packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java
@@ -3201,6 +3201,8 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener, Dumpab
         if (isUserUnlocked(getCurrentUser())) {
             return false;
         }
+        // ISLET added
+        if (true) { Log.w(TAG, "[ISLET] no HOME INTENT"); return true; }
         Intent homeIntent = new Intent(Intent.ACTION_MAIN).addCategory(Intent.CATEGORY_HOME);
         ResolveInfo resolveInfo = mContext.getPackageManager().resolveActivityAsUser(homeIntent,
                 0 /* flags */, getCurrentUser());
diff --git a/packages/SystemUI/src/com/android/systemui/keyguard/WorkLockActivity.java b/packages/SystemUI/src/com/android/systemui/keyguard/WorkLockActivity.java
index 546a4093ec7d..07dcba764657 100644
--- a/packages/SystemUI/src/com/android/systemui/keyguard/WorkLockActivity.java
+++ b/packages/SystemUI/src/com/android/systemui/keyguard/WorkLockActivity.java
@@ -201,6 +201,8 @@ public class WorkLockActivity extends Activity {
     }
 
     private void goToHomeScreen() {
+        // ISLET added
+        if (true) return;
         final Intent homeIntent = new Intent(Intent.ACTION_MAIN);
         homeIntent.addCategory(Intent.CATEGORY_HOME);
         homeIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
diff --git a/services/core/java/com/android/server/SystemServerInitThreadPool.java b/services/core/java/com/android/server/SystemServerInitThreadPool.java
index 63e7563af6d1..fbbb64bca157 100644
--- a/services/core/java/com/android/server/SystemServerInitThreadPool.java
+++ b/services/core/java/com/android/server/SystemServerInitThreadPool.java
@@ -177,8 +177,11 @@ public final class SystemServerInitThreadPool implements Dumpable {
                     copy.addAll(sInstance.mPendingTasks);
                 }
                 t.traceEnd();
-                throw new IllegalStateException("Cannot shutdown. Unstarted tasks "
+                Slog.d(TAG, "[ISLET] Shutdown successful"
+                        +  "Cannot shutdown. Unstarted tasks "
                         + unstartedRunnables + " Unfinished tasks " + copy);
+                //throw new IllegalStateException("Cannot shutdown. Unstarted tasks "
+                //        + unstartedRunnables + " Unfinished tasks " + copy);
             }
             sInstance = null; // Make eligible for GC
             Slog.d(TAG, "Shutdown successful");
diff --git a/services/core/java/com/android/server/SystemServiceManager.java b/services/core/java/com/android/server/SystemServiceManager.java
index 78df983c83f7..425973f2fb35 100644
--- a/services/core/java/com/android/server/SystemServiceManager.java
+++ b/services/core/java/com/android/server/SystemServiceManager.java
@@ -293,10 +293,14 @@ public final class SystemServiceManager implements Dumpable {
                 try {
                     service.onBootPhase(mCurrentPhase);
                 } catch (Exception ex) {
-                    throw new RuntimeException("Failed to boot service "
+                    Slog.i(TAG, "ISLET" + "Failed to boot service "
                             + service.getClass().getName()
                             + ": onBootPhase threw an exception during phase "
-                            + mCurrentPhase, ex);
+                            + mCurrentPhase);
+                    //throw new RuntimeException("Failed to boot service "
+                    //        + service.getClass().getName()
+                    //        + ": onBootPhase threw an exception during phase "
+                    //        + mCurrentPhase, ex);
                 }
                 warnIfTooLong(SystemClock.elapsedRealtime() - time, service, "onBootPhase");
                 t.traceEnd();
diff --git a/services/core/java/com/android/server/UiModeManagerService.java b/services/core/java/com/android/server/UiModeManagerService.java
index c853ba93f4ab..af101035f041 100644
--- a/services/core/java/com/android/server/UiModeManagerService.java
+++ b/services/core/java/com/android/server/UiModeManagerService.java
@@ -1728,7 +1728,9 @@ final class UiModeManagerService extends SystemService {
                         + mDockState +", category=" + category);
             }
 
-            sendConfigurationAndStartDreamOrDockAppLocked(category);
+            // ISLET disabled
+            Slog.w(TAG, "[ISLET] UiModeManagerService.jav:aupdateLocked() no HOME intent");
+            //sendConfigurationAndStartDreamOrDockAppLocked(category);
         }
 
         // keep screen on when charging and in car mode
diff --git a/services/core/java/com/android/server/wm/ActivityTaskManagerService.java b/services/core/java/com/android/server/wm/ActivityTaskManagerService.java
index aa154292fe7e..924ff0edb4fb 100644
--- a/services/core/java/com/android/server/wm/ActivityTaskManagerService.java
+++ b/services/core/java/com/android/server/wm/ActivityTaskManagerService.java
@@ -4977,9 +4977,11 @@ public class ActivityTaskManagerService extends IActivityTaskManager.Stub {
         Intent intent = new Intent(mTopAction, mTopData != null ? Uri.parse(mTopData) : null);
         intent.setComponent(mTopComponent);
         intent.addFlags(Intent.FLAG_DEBUG_TRIAGED_MISSING);
-        if (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
-            intent.addCategory(Intent.CATEGORY_HOME);
-        }
+        // ISLET added
+        Slog.w(TAG, "[ISLET] getHomeIntent() omit CATEGORY_HOME");
+        //if (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
+        //    intent.addCategory(Intent.CATEGORY_HOME);
+        //}
         return intent;
     }
 
@@ -5872,6 +5874,8 @@ public class ActivityTaskManagerService extends IActivityTaskManager.Stub {
 
         @Override
         public boolean startHomeActivity(int userId, String reason) {
+            // ISLET dislabled
+            if (true) { Slog.w(TAG, "[ISLET] disable startHomeActivity"); return true;}
             synchronized (mGlobalLock) {
                 return mRootWindowContainer.startHomeOnDisplay(userId, reason, DEFAULT_DISPLAY);
             }
@@ -5880,6 +5884,8 @@ public class ActivityTaskManagerService extends IActivityTaskManager.Stub {
         @Override
         public boolean startHomeOnDisplay(int userId, String reason, int displayId,
                 boolean allowInstrumenting, boolean fromHomeKey) {
+            // ISLET dislabled
+            if (true) { Slog.w(TAG, "[ISLET] disable startHomeOnDisplay"); return true;}
             synchronized (mGlobalLock) {
                 return mRootWindowContainer.startHomeOnDisplay(userId, reason, displayId,
                         allowInstrumenting, fromHomeKey);
@@ -5888,6 +5894,8 @@ public class ActivityTaskManagerService extends IActivityTaskManager.Stub {
 
         @Override
         public boolean startHomeOnAllDisplays(int userId, String reason) {
+            // ISLET dislabled
+            if (true) { Slog.w(TAG, "[ISLET] disable startHomeOnAllDisplays"); return true;}
             synchronized (mGlobalLock) {
                 return mRootWindowContainer.startHomeOnAllDisplays(userId, reason);
             }

project libcore/
diff --git a/libart/src/main/java/java/lang/Daemons.java b/libart/src/main/java/java/lang/Daemons.java
index 5b2adb366c7..d67f3ae1fed 100644
--- a/libart/src/main/java/java/lang/Daemons.java
+++ b/libart/src/main/java/java/lang/Daemons.java
@@ -367,7 +367,9 @@ public final class Daemons {
                     continue;
                 }
                 final TimeoutException exception = waitForProgress();
-                if (exception != null && !VMDebug.isDebuggerConnected()) {
+                // ISLET Change
+                //if (exception != null && !VMDebug.isDebuggerConnected()) {
+                if (false) {
                     timedOut(exception);
                     break;
                 }

project system/netd/
diff --git a/server/TetherController.cpp b/server/TetherController.cpp
index 79193574..80363e0a 100644
--- a/server/TetherController.cpp
+++ b/server/TetherController.cpp
@@ -67,7 +67,7 @@ using android::base::StringPrintf;
 using android::base::unique_fd;
 using android::netdutils::DumpWriter;
 using android::netdutils::ScopedIndent;
-using android::netdutils::statusFromErrno;
+// using android::netdutils::statusFromErrno;
 using android::netdutils::StatusOr;
 
 namespace {
@@ -912,14 +912,19 @@ StatusOr<TetherController::TetherStatsList> TetherController::getTetherStats() {
     for (const IptablesTarget target : {V4, V6}) {
         std::string statsString;
         if (int ret = iptablesRestoreFunction(target, GET_TETHER_STATS_COMMAND, &statsString)) {
-            return statusFromErrno(-ret, StringPrintf("failed to fetch tether stats (%d): %d",
-                                                      target, ret));
+            gLog.log("[ISLET] %s \n", StringPrintf("failed to fetch tether stats (%d): %d",
+                                                      target, ret).c_str());
+            // return statusFromErrno(-ret, StringPrintf("failed to fetch tether stats (%d): %d",
+            //                                           target, ret));
         }
 
         if (int ret = addForwardChainStats(statsList, statsString, parsedIptablesOutput)) {
-            return statusFromErrno(-ret, StringPrintf("failed to parse %s tether stats:\n%s",
+            gLog.log("[ISLET] %s\n", StringPrintf("failed to parse %s tether stats:\n%s",
                                                       target == V4 ? "IPv4": "IPv6",
-                                                      parsedIptablesOutput.c_str()));
+                                                      parsedIptablesOutput.c_str()).c_str());
+            // return statusFromErrno(-ret, StringPrintf("failed to parse %s tether stats:\n%s",
+            //                                           target == V4 ? "IPv4": "IPv6",
+            //                                           parsedIptablesOutput.c_str()));
         }
     }
 
